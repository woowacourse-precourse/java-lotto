# 3주차 미션 - 로또
## 📌 기능 목록
로또 게임은 아래와 같은 기능들로 이루어져 있다.
### ✅ 입력
- 사용자로부터 로또 금액을 입력받는다.
```text
[입력예외] 숫자 외에 다른 문자를 입력하면 발생
```
- 사용자로부터 당첨 번호를 입력받는다.
```text
[입력예외] 'n,n,n,n,n,n' 입력 형식을 지키지 않았을 때 발생
[입력예외] 숫자 외에 다른 문자를 입력하면 발생
```
- 사용자로부터 보너스 번호를 입력받는다.
```text
[입력예외] 숫자 외에 다른 문자를 입력하면 발생
```
### ✅ 출력
- 게임 진행 상황을 출력한다.
- 생성된 로또들의 번호를 출력한다.
  - 로또 번호는 오름차순으로 정렬한다.
```text
3개를 구매했습니다.
[8, 21, 23, 41, 42, 43] 
[3, 5, 11, 16, 32, 38] 
[7, 11, 16, 35, 36, 44] 
```
- 로또 추첨 결과를 출력한다. 
```text
당첨 통계
---
3개 일치 (5,000원) - 1개
4개 일치 (50,000원) - 0개
5개 일치 (1,500,000원) - 0개
5개 일치, 보너스 볼 일치 (30,000,000원) - 0개
6개 일치 (2,000,000,000원) - 0개
```
- 수익률을 출력한다.
```text
총 수익률은 62.5%입니다.
```
### ✅ 로또 생성
- 입력받은 (구입금액 ÷ 1000)의 값 만큼 1 ~ 45 숫자 6개로 이루어진 로또 생성 
```text
[조건예외] 생성된 로또가 6자리가 아니면 예외 발생
[조건예외] 생성된 로또의 번호가 중복되면 발생
[조건예외] 사용자가 1000으로 나누어 떨어지지 않는 숫자를 입력하면 발생
```

### ✅ 당첨 결과 계산
- 입력받은 당첨번호를 검증한다.
```text
[조건예외] 사용자가 입력한 숫자가 6개가 아니면 예외 발생
[조건예외] 사용자가 중복된 숫자를 입력한 경우 예외 발생
[조건예외] 각각의 인자가 1 ~ 45의 숫자가 아니면 예외 발생
```
- 입력받은 보너스 번호를 검증한다.
```text
[조건예외] 당첨 번호이 입력받은 보너스 번호가 존재하면 발생
[조건예외] 1 ~ 45의 숫자가 아니면 발생
```

- 입력받은 `로또 번호`, `당첨번호` 그리고 `보너스 번호`를 대조하여 당첨결과를 반환한다.
  - `1등` : 6개 포함
  - `2등` : 5개 포함 + 보너스 번호
  - `3등` : 5개 포함
  - `4등` : 4개 포함 
  - `5등` : 3개 포함
- 당첨 번호의 개수가 5개라면 보너스 번호까지 대조하여 `2등`과 `3등`을 구분한다.
- 그 외의 경우 (1개 혹은 2개 맞춘 경우)에 대해서는 무시한다.
### ✅ 당첨 통계
- 당첨 결과를 바탕으로 각각의 맞춘 개수에 해당하는 당첨금을 더하여 수익률을 계산한다.
  - `1등` : 2,000,000,000원
  - `2등` : 30,000,000원
  - `3등` : 1,500,000원
  - `4등` : 50,000원
  - `5등` : 5,000원
- 수익률은 소수점 둘째 자리에서 반올림한다.
### ✅ 예외 발생
- 예외는 사용자의 입력 단계에서 검증하는 `입력예외`와 객체 생성 시 검증하는 `조건예외`로 나눈다.
- 각각의 예외는 검증하는 단계에서 예외를 발생시킨다. ex) `조건예외`는 객체 생성 시 예외를 발생시킨다.
- `IllegalArgumentException.class`를 발생시키고, 각 예외를 설명하는 메시지를 담아 출력한다.
- 모든 예외 메시지는 `[ERROR]`로 시작한다.
- 예외가 발생하면 프로그램은 즉시 종료된다.



## 😁 소감
저번 주차에서 부족했다고 생각했던 메소드 분리와 도메인 별 테스트 작성을 중점적으로 여기며 미션을 수행했고, 다양한 JUnit 및 AssertJ의 기능을 사용하면서 유연하게 테스트 코드를 작성하려고 노력했습니다.
또한 예외적인 상황에 대한 테스트 케이스만 추가한 것이 아닌 정상적인 실행이 되는 케이스 코드도 추가하고, 입력 값에 따라 다른 결과 값에 대해서도 다양한 테스트 케이스를 작성했습니다.

애플리케이션을 조금이라도 더 객체지향적으로 설계하기 위해 Dependency Injection을 활용하여 실행 주체가 직접 의존하는 객체를 정하는 것이 아닌, LottoContainer를 통해 의존성을 주입 받도록 설계했습니다. 결과적으로 추후 로또의 규칙이나 다른 기능이 추가될 때 유연하게 기능을 더 할 수 있는 코드를 작성하려고 노력했습니다.

조금 어려웠던 부분이 있었다면 도메인 별로 기능을 분리했기 때문에 예외 검증을 하는 부분이 조금 까다로웠습니다. 저 같은 경우는 당첨번호를 WinningBalls와 BonusBall로 구분했습니다. 그리고 이들을 감싸는 Balls 클래스를 추가했습니다. 그리고 각각의 도메인들이 생성될 때 validate를 하는 방식으로 구현을 했습니다. 이 방식의 단점이라면 바로 값에 대한 검증이 여러 부분에 걸쳐 진행된다는 점 입니다. 입력값 즉 값의 잘못이 아닌, 입력에 대한 예외를 검증할 때에는 LottoInputerValidator에서 검증을 진행하게 됩니다. 하지만 값에 대한 검증은 각각의 도메인의 생성자에서 진행되게 됩니다. 이처럼 예외 검증 로직이 분리되어있기 때문에 코드의 복잡성이 조금 올라간다는 단점이 존재합니다. 하지만 예외의 종류를 명확하게 구분하고 분리하여 코드를 좀 더 유연하게 작성할 수 있었습니다.

주변에서 쉽게 접할 수 있는 로또게임이지만, 이를 구현하기 위해 많은 고민을 하고 클린하게 코드를 작성하려다 보니 조금 더 복잡하게 작성한 것 같은 기분도 들긴합니다. 하지만 그런 고민들을 통해 어떻게 하면 코드를 더 가볍고, 클린하게 작성할 수 있을지에 대한 경험과 노하우도 생기는 것 같습니다. 앞으로 이런 고민들을 계속하며 코드를 작성한다면 누구나 보기 쉽고 파악하기 쉬운 코드를 작성할 수 있을 것 같습니다! 😀



