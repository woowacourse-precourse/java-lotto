# 미션 - 로또

이 프로젝트는 2022년 우아한 테크코스-프리코스의 3주차 미션인 '로또'를 수행한 것으로, 금액만큼 로또를 자동으로 발급하고, 당첨 결과를 조회하는 프로그램이다.   
이 미션은 1) 클래스를 분리하고 2) 도메인 로직에 대한 단위 테스트를 작성하는 법을 익히는 것을 목표로 한다.

## 기능 목록

+ 기능 목록은 크게 로또를 발행하고, 당첨결과를 계산하는 등의 로또에 대한 핵심 로직을 담은 **도메인**과, 콘솔에서의 **입출력**으로 나누어서 작성하였다.
+ 형식 : 기능 설명 - 소속 클래스 #메소드 명(혹은 생성자)
+ 들여쓰기의 의미: 함수의 부분 기능을 담당하지만 따로 분리해서 구현되는 기능은 한 단계 들여쓰기 하여 작성하였다. 들여쓰기된 기능은 상위 기능에 의해 호출된다.

### 도메인

- 로또 금액 만큼 로또를 발행한다. - LottoGenerator #generateLottos()
    - 로또 구입 금액이 1000원으로 나누어 떨어지지 않으면 예외 처리한다 - LottoGenerator #validate()
    - 발행할 로또 개수를 구한다. - LottoGenerator #getIssueCount()
    - 1개의 로또를 발행한다.(1부터 45까지의 숫자 중 서로 다른 숫자 6개 숫자를 뽑는다) - LottoGenerator #generateLotto()


- 발행된 로또를 저장한다. - Lotto #Lotto()
    - 발행된 로또가 유효한지 검사한다 - Lotto #validate()
        - 숫자가 1~45사이를 벗어나는지 확인한다. - Lotto #isInRange()
        - 6개의 숫자인지 확인한다 - Lotto #isProperSize()
        - 숫자가 중복되는지 확인한다. - Lotto #isAllNumberUnique()


- 해당 회차의 당첨 숫자 및 보너스 숫자를 저장한다. - WinningNumbers - WinningNumbers()
    - 당첨 숫자를 저장한다.
    - 보너스 숫자가 유효한지 검사한다 - WinningNumbers #validateBonusNumber()
        - 숫자가 1~45사이를 벗어나는지 확인한다. - WinningNumbers #isBonusNumberUnique()
        - 숫자가 중복되는지 확인한다. - WinningNumbers #isBonusNumberInRange()


- 매 로또마다 몇 개의 숫자가 당첨 숫자와 일치하는지 확인한다. - LottoCalculator #calculateRank()
    - 각 숫자가 당첨 숫자에 포함되는지 확인한다. - WinningNumbers #contains()
    - 각 숫자가 보너스 숫자와 일치하는 확인한다. - WinningNumbers #isEqualToBonusNumber()


- 전체 로또에 대해서 수익률을 계산한다. -LottoCalculator #calculateEarningsRatio()
    - 전체 로또에 대해서 총 상금을 구한다 - LottoCalculator # calculateTotalPrize()
    - 총상금과 복권 구입 금액을 이용해서 수익률을 계산한다

### 입, 출력

- 로또 구입 금액을 입력받는다.
    - '구입 금액을 입력해 주세요.' 출력
    - 숫자가 아닌 수를 입력할 경우 예외를 발생시킨다.


- 총 로또 구입 갯수 및 각 로또 번호를 출력한다.


- 당첨 번호를 입력받는다.
    - '당첨 번호를 입력해 주세요.' 출력
    - ','와 숫자를 제외한 입력이 들어있으면 예외를 발생시킨다.
    - ','를 기준으로 분리한다.


- 보너스 번호를 입력받는다.
    - '보너스 번호를 입력해 주세요.' 출력
    - 숫자가 아닌 수를 입력할 경우 예외를 발생시킨다.


- 당첨 통계 출력
    - '당첨 통계\n---' 출력
    - 1~5등 각 등수별 통계 내림차순 출력: n개 일치 (#,###원) - x개.
    - 수익률 출력.
## 프로젝트 구조
- **lotto 패키지**는 크게 **console**과 **domain**으로 나뉜다. domain 패키지는 비지니스 로직과 관련된 모든 클래스를 포함하고, console 패키지는 화면 입출력과 관련된 클래스를 포함한다.
- [기능목록](#기능목록)에서 [도메인](#도메인) 기능은 domain 패키지에, [입출력](#입출력) 기능은 console패키지에 구현하였다.
-   domain 패키지의 각 클래스는 1:1로 매칭되는 테스트 클래스를 가진다. 각 테스트 클래스는 매칭되는 클래스의 단위 테스트를 담당한다. 다만, 1) Enum 클래스 2) 상수만 가지는 클래스 3) 데이터를 제공하는 기능을 제외한 특별한 기능이 없는 경우에는 테스트할 필요가 없어 테스트 클래스가 존재하지 않는다.
-  console 패키지의 클래스는 테스트 클래스가 존재하지 않는다. 요구사항에 의해 UI 로직은 테스트 대상이 아니다.
-  프로젝트 구조와 각 파일이 담당하는 역할을 기술하였다.
```bash
└── src
    ├── main
    │   └── java
    │       └── lotto
    │           ├── Application.java
    │           ├── console
    │           │   ├── In.java : 화면 입력
    │           │   └── Out.java : 화면 출력
    │           └── domain
    │               ├── Lotto.java : 로또 한장
    │               ├── Lottos.java : 로또 묶음
    │               ├── WinningNumbers.java : 추첨 결과(당첨 번호와 보너스 번호)
    │               ├── LottoResult.java : 로또 당첨 결과
    │               ├── Validator.java : 로또 유효성 검증
    │               ├── LottoGenerator.java : 로또 자동 발행
    │               ├── LottoRankCalculator.java : 로또 순위 계산
    │               ├── LottoResultCalculator.java : 로또 상금 및 수익률 계산
    │               ├── LottoRank.java : 로또 순위 정책 Enum.
    │               └── LottoRule.java : 로또 규칙과 관련된 상수들
    └── test
        └── java
            └── lotto
                ├── ApplicationTest.java
                └── domain
                    ├── LottoTest.java
                    ├── WinningNumbersTest.java
                    ├── ValidatorTest.java
                    ├── LottoGeneratorTest.java
                    ├── LottoRankCalculatorTest.java
                    └── LottoResultCalculatorTest.java
```

##  느낀점과 배운점
### 설계
+ **클래스를 분리**하는 이유: 프로그래머는 소스코드로 소통하는 사람들이다. 하고 싶은 말을 길게 한 문장으로 적는 것보다, 주제별로 나누고 주제를 잘 나타내는 제목을 지어야 상대방이 알아듣기에 더 편하다. 소스코드도 마찬가지이다. 클래스를 역할과 책임에 따라 잘 분리해 놓아야 다른 개발자가 이해하기 쉽다. 또, 분리가 되어 있어야 수정이 필요할때 어떤 파일을 수정해야하는지 찾기가 쉽다. 클래스를 잘 분리하는 것은 응집도를 높이고, 결합도를 낮추는 것도 포함된다. 어떤 주제에 대해서 수정하고자 할때는 그 주제만 수정하면 되도록 설계가 되어야 한다.
  > 모든 모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬어야 한다.
  > [출처] 오브젝트, 조영호
+ 모든 것은 요구사항을 기준으로 결정하자.
    + '수익률이 300050%일때 300050.0%로 출력하는게 맞나 300050%로 출력하는게 맞나?' 고민이 된다면 요구사항을 살펴보자. 명확하게 요구사항에 적혀있지 않지만 예시가 모두 소수점 첫째자리까지 출력하고 있으니 300050.0%로 출력하자고 결정하였다.
+ 모든 것은 **요구사항을 기준으**로 결정하되, **공통 사항들을 구현 전에 미리 정리**해 두는게 좋다.
    + 에러 메세지를 한국어로 할 건지, 영어로 할건지와 같은 사소한 사항조차 중간에 변경하려고 하면 시간이 낭비되므로 미리 결정해두자. 요구사항에서 에러 메세지 예시가 한국어로 되어 있으니 한국어로 하자.
    + '당첨 번호'라고 할건지 '추첨 번호'라고 할건지, '보너스 번호'라고 할건지 '보너스 숫자'라고 할건지 용어를 혼용하지 않는게 좋다. 사소한 차이지만 혼용한다면 작성하는 입장에서도 매번 어떤 용어를 쓸지 고민해야하고, 수정이 필요해 사용된 곳을 찾고자 해도 단어가 정확히 일치하지 않아 찾기가 힘들다. 또, 받아들이는 입장에서도 용어가 의미하는 바가 혼란스러울 수 있다. 요구사항에서 사용된 용어로 통일해서 사용하자.
+ LottoRank라는 Enum클래스를 생성하여 각 당첨 순위별 일치하는 숫자 개수, 보너스 숫자의 일치 여부, 상금을 저장해둠. 각 로또에 대한 당첨 결과를 Map<Lotto, LottoRank> 형식으로 저장하면 로또와 그 당첨 결과 및 상금을 한번에 쉽게 조회할 수 있다.
+ 입출력 클래스에서는 입력된 값이 형식에 맞는지(예를 들어, 금액의 경우 숫자인지만 확인)만하고 비지니스 로직에 대한 확인(금액이 0원 미만인지, 로또 가격으로 나누어떨어지지 않는지 등)은 domain 패키지 - LottoGenerator 클래스에서 담당하도록 하였다. 이를 통해 입출력과 비지니스 로직을 분리할 수 있고, 금액에 대한 검증 로직이 변경되어도 LottoGenerator 한 곳에서만 수정해주면 된다.
+ 발행한 로또 티켓 묶음을 Lottos라는 **일급 컬렉션**으로 관리하여 비지니스에 종속적인 자료구조를 구현하였다. Lottos 클래스는 ```List<Lotto>``` 형식의 로또 묶음 뿐 아니라, 로또별 당첨 결과에 대한 정보도 ```Map<Lotto, LottoRank>``` 형식으로 가지고 있다. 로또 묶음과 각 로또의 당첨결과는 서로 1:1의 관계를 가진다. 각각의 변수로 떠돌아다니는게 아니라 한 클래스로 묶어서 관리하는 것이 자연스럽다.
    + 일급 컬렉션은(first class collection)은 iterator를 따로 구현해야 한다는 것을 주의하자! implement iterable 인터페이스를 상속한 후 iterator() 메소드에서 list의 iterator를 반환해주어야 한다.
+ 출력해야하는 정보는 각 등수별 당첨된 로또 개수이지만, 실제로는 각 로또별 당첨 결과를 저장해두었다.
    + 이유 1) '예상을 빗나가지 않는 코드'를 작성하는게 중요한데, 각 로또별 당첨 결과는 없이 등수별로 당첨된 로또 개수를 저장해두는게 현실과 다르다고 생각하였다.
    + 이유 2) 각 등수별 당첨된 로또 개수는, 로또별 당첨 결과를 알고 있다면 계산이 가능하다. 필요할때 계산한 후 출력하면 된다.
+ 메소드의 이름이 행위를 명확하게 드러낼 수 있도록 고민하였다. 단순이 필드 값을 반환하는 것이라면 get~(), 계산한 값을 반환하는 것이라면 calculate~()  ex) calculateRateOfReturn() 으로 세분화하였다. 이렇게 하면, 다른 곳에서 사용될때 메소드만 보고도 어떤 기능을 하는지 유추할 수 있다.
+ LottoRankCalculator.class에서 당첨 번호와 일치하는 숫자의 개수를 계산하고자 할때 WinningNumbers.class에 메세지를 보내 확인한다.
    + getter로 WinningNumbers의 숫자를 가져와서 비교하지 않는다
    + 번호가 포함되어 있는지 알려달라고 WInningNumbers에 메세지를 보낸다.
    + 응집도가 낮아진다. 데이터를 사용하는 프로세스가 데이터를 소유하고 있는 클래스 내부에 위치한다.
+ IllegalArgument를 발생시키면서 메세지에 구체적인 에러 발생 원인을 기술한다.  프로그램에서 발생한 모든 IllegalArgumentException을 catch해 에러 메세지 출력 함수를 실행하면서 [ERROR] 태그를 붙여준다.
    + 태그와 메세지를 분리한다. 태그만 수정 가능
+ 당첨번호는 6개의 당첨 번호와 1개의 보너스 번호로 이루어져 있는데, 당첨 번호는 자동으로 발급되는 로또의 번호와 유효성 검증 로직이 일치한다. Validator라는 클래스를 만들어서 WinningNumbers와 Lotto 클래스가 공유할 수 있도록 했다.
+ 기능 목록을 실제 구현할 것을 고려하면서 오랜 시간을 들여서 자세하게 작성하고 나니 다음과 같은 장점이 있었다.
    1) 설계가 명확하니 구현이 빨라진다.
    2) 기능 목록 순서대로 진행할 수 있어 내 작업이 어디까지 진행됐는지 알 수 있다.
    3) 클래스 분리와 메소드 분리까지 고려하면서 기능목록을 작성하니 수정이 적어진다.
+ 구입금액을 0으로 입력해도 예외를 발생시키지 않았다. 금액이 0인 것은 예외를 발생하는 것보다, 구입한 로또가 0개이고 수익률이 0%인 것인 더 현실을 반영한다고 생각하였다.
+  [숫자 야구 게임]미션을 진행하면서 IllegalArgumentException이 발생하면 호출한 메소드에서 예외 핸들링을 해주지 않아도 되는게 바로 프로그램이 종료되기 때문이라고 생각했는데, IllegalAccessException을 발생시키려고 하니 에러 핸들링이 필요하다는 메세지가 떴다. 자바 예외 구분에 대해서 알아보며 예외와 오류의 차이, Checked Exception과 Unchecked Exception의 차이에 대해서 알 수 있었다. IllegalArgumentException은 RuntimeException을 상속하기 때문에 명시적으로 예외 처리를 하지 않아도 된다.
+ Lotto 생성자에서 유효성 검증을 강제하고 다른 메소드에서 LottoCalculator와 같은 클래스에서 매개변수로 Lotto를 받으면 이미 유효성 검증이 끝난 것을 보장할 수 있다.
+ LottoGenerator, LottoRankCalculator, LottoResultCalculator의 경우 static메소드만 가지는 클래스로 수정하고, 생성자를 private으로 제한해 객체를 생성하지 못하게 했다. Math 클래스와 같이 유틸리티 클래스(또는 헬퍼 클래스) 구조를 가지도록 했다. 상태를 내포하지 않고, 단순히 계산하는 역할만 해, 메모리 낭비를 하지 못하게 객체 생성을 방지하기 위해서이다. 그런데 찾아보니 유틸리티 클래스를 객체지향에서 악으로 본다고도 하니 더 조사가 필요하다.
+ Map<Lotto, LottoRank> 형식으로 저장된 로또별 순위 정보를 LottoResult.class 생성자에 매개변수로 넘기면 생성자 안에서 전체 상금과 수익률을 계산해서 필드로 저장하도록 했다. 로또별 순위 정보만 있다면 당첨금과 수익률이 계산할 수 있고, 자동으로 계산되고 저장되는게 편리하다고 생각했다. 한편으로는, 내부 구현을 알지 못하는 외부에서 LottoResult 객체를 생성만 하면 상금이나 수익률에 대한 정보가 계산될 것이라는 것을 알지 못할 거 같기도 하다.
+ 당첨 통계 메시지 형식을 1) 당첨 통계를 담당하는 클래스의 toString()함수를 오버라이딩해서 지정 2) 출력함수 안에서 지정하는 방식 중 2)를 택했다. 1)의 경우 어디서나 공통적인 형식을 사용할 수 있다는 장점이 있지만, 출력 형식은 비지니스 형식과 관련이 없고 분리되어야 한다고 생각해 2)를 택하였다.

###  Java
+ 제네릭: toArray()에 대한 API 도큐먼트를 보는데 제네릭 표현을 이해할 수 없었다. '이것이 자바다'책의 제네릭에 대한 챕터를 읽고 API도큐먼트를 정확히 이해할 수 있었다.
### 테스트
+ 테스트를 작성해야하는 가장 큰 이유는 수정 전후에 미치는 역효과가 없는지 검증하기 위해서 인 것 같다. 구현하다보면 수정이 빈번하게 발생하는데, 한 클래스의 수정이 다른 클래스에 영향을 미치는 경우가 있고, 많은 경우 놓친다. 테스트 코드를 작성해 수정이 필요한 곳을 놓치는 것을 방지할 수 있다. 만약 내가 예상하지 못한 곳에서 수정이 필요하다면, 설계가 잘못되지 않았는지, 결합도를 낮출 수 없는지 고민하는게 필요하다.
+ +테스트하면서 하니, 에러 메시지조차도 "1000으로 나누어 떨어지지 않습니다" 보다 조금 더 범용적인 경우도 포함할 수 있도록 잘못된 금액입니다 표시 "구입 금액은 로또 가격의 배수여야 합ㄴ디ㅏ"
+ parameterized test에서 csv source를 사용하면 자동 형변환해서 받아준다.
    +  String, Int, boolean은 자동으로,  Long이나 Double은 숫자 뒤에 l, d붙여주면 자동 형변환 됨.
    + list를 매개변수로 주고 싶다면 method source를 사용해야한다.
+ assertThat함수에서 actual, expected 항목 순서를 지켜주자. isEqualTo()로 비교하는 경우 둘이 같은지만 알면 된다고 생각해서 순서를 신경쓰지 않고 넣어주니 테스트에 실패하는 경우 무엇이 잘못되었는지 확인하기가 어려웠다.
+ 당첨 상금이 많이 커지면 어떻게 되는지 확인하고 싶어서 1등에 100명이 당첨되는 경우 테스트하고 싶었는데 더 좋은 방법이 없는지 살펴봐야 겠다.
    + 매개변수로 로또 번호를 담은 리스트를 총 100개 넘겨주어야 하는데 Java에서는 unpacking을 지원하지 않는다.
    + toArray()로 list를 배열로 변환하면 generic array creation 에러가 발생한다.
    + '이가 없으면 잇몸으로'라는 마음가짐으로 100개의 배열을 일일이 매개변수에 대입해주었다.
+ assertEquals()는 List형을 toString()으로 비교하기 때문에 원소 값이 같은지 비교 가능하다.

### Git
+ 기능 목록과 커밋 순서를 일치시키려고 노력했다.
+ 변경사항을 분리하기가 어렵다. 한번에 커밋해버리고 싶은 유혹을 떨쳐야 한다. 작업하다보면 이거 고치면 저것 고치려고 생각나고 한번에 수정하고 나면 커밋 분리하기가 어렵다. 파일별로 스테이징 해서 관련있는 수정사항끼리 묶어서 커밋해야 한다.
+ 함수가 반환하는 값을 로직에 맞게 수정한다고 했을때 commit message에서 refactor fix, feat, bug 중 무엇인지 더 고민해보아야겠다. 기능을 추가하는 것이 아니라서 refactor라고 생각하였다.
+ 기능 별로 커밋해주기 위해서 파일별로 스테이징 하는데 파일경로 매번 모드 쓰려니 힘들다. single quotation안에 wildcard사용하면 경로 생략 가능. ex) git add '*/Lotto.java"
