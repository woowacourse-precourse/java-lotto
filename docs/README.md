# ⚾︎ 미션 - 로또


## 👀 문제 확인하기
- 우아한테크코스 3주차 과제 중 '**로또**'의 구현 기능과 구현 로직을 담은 문서입니다.
- 문제는 [여기](https://github.com/woowacourse-precourse/java-lotto)에서 확인해 주세요.

---

## 🌟 구현 기능 목록

### ☑️ 사용자 입력 기능
- 사용자로부터 값을 입력받는다.
  - *InputUtil#getUserInput()*

### ☑️ 제한사항 검증 기능
- 사용자의 입력값에 대한 검증 기능을 제공한다. 다음과 같은 경우 예외 사항으로 판단한다.
  - [예외] 입력받은 구입 금액이 1,000으로 나누어 떨어지지 않는 경우 
    - *ValidationUtil#validatePurchase()*
  - [예외] 입력받은 당첨 번호의 개수가 6개가 아닌 경우  
    - *ValidationUtil#validatedWinningCount()*
  - [예외] 입력받은 당첨 번호에 공백값이 들어있는 경우 
    - *ValidationUtil#validateBlank()*
  - [예외] 입력받은 당첨 번호에 중복된 값이 있는 경우 
    - *ValidationUtil#validateDuplicate()*
  - [예외] 입력받은 당첨 번호가 1~45 사이의 값이 아닌 경우 
    - *ValidationUtil#validateWinningRange()*
  - [예외] 입력받은 보너스 번호가 1~45 사이의 값이 아닌 경우 
    - *ValidationUtil#validateBonusRange()*
- 예외 사항에 대해서는 예외 메시지 출력 및 `IllegalArgumentException`를 발생시킨다.

### ☑️ 로또 번호 발행 기능
- 1~45 사이의 값을 가지는 로또 번호 6개를 랜덤하게 생성한다.
- *LottoPurchase#generateLottoNumbers()*

### ☑️ 로또 구매 개수 계산 기능
- 사용자가 몇 장의 로또를 구매했는지 계산한다.
- *LottoPurchase#getPurchaseCount()*

### ☑️ 로또 번호 비교 기능
- 발행한 로또 번호와 당첨 번호가 일치하는 개수를 계산한다.
- *LottoPrize#getMatchCount()*

### ☑️ 로또 당첨 금액 계산 기능
- 사용자가 당첨된 로또의 총 금액을 계산한다.
- *LottoPrize#getTotalWinningAmount()*

### ☑️ 수익률 계산 기능
- 사용자의 구입 금액과 당첨된 경우 받을 수 있는 금액에 대하여 수익률을 계산하여 리턴한다.
- *LottoPrize#computeEarningRate()*

### ☑️ 메시지 출력 기능 
- 프로그램을 진행하며 출력되는 메시지를 관리한다.
  - 가장 먼저 `구입금액을 입력해 주세요.`를 출력한다.
    - *MessageUtil#printPurchaseInput()*
  - 구입한 개수에 따라 `x개를 구매했습니다.`와 발행한 로또 번호를 `[1, 2, 3, 4, 5, 6, 7, 8]`와 같은 형식으로 출력한다.
    - *MessageUtil#printPurchaseCount()*
  - 당첨 번호 입력 시 `당첨 번호를 입력해 주세요.`를 출력한다.
    - *MessageUtil#printWinningInput()*
  - 보너스 번호 입력 시 `보너스 번호를 입력해 주세요.`를 출력한다.
    - *MessageUtil#printBonusInput()*
  - 당첨 통계 안내 시 `당첨 통계`, `---`를 출력하고 일치하는 개수에 따라 값을 출력한다.
    - *MessageUtil#printWinningStats()*
    - `x개 일치 (y원) - z개` 형식으로 출력한다.
      - *MessageUtil#printWinningStatsResult()*
    - 수익률 안내 시 `총 수익률은 x%입니다.`를 출력한다.
      - *MessageUtil#printEarningRate()*
---

## 💡 구현 로직
~~~
1. 사용자로부터 구입 금액을 입력받는다.
  - 입력받은 구입 금액에 대한 검증을 진행한다.
2. 입력받은 구입 금액에 따라 로또 구매 개수를 계산한 뒤, 구매 개수에 따라 로또 번호를 발행한다.
3. 사용자로부터 당첨 번호와 보너스 번호를 입력받는다.
  - 입력받은 당첨 번호와 보너스 번호에 대한 검증을 진행한다.
4. 당첨 번호와 발행된 로또 번호를 비교하여 로또 통계 결과를 계산한다.
  - 일치하는 개수에 따라 결과를 저장해둔다.
  - 최종 일치 개수를 바탕으로 당첨 금액을 계산한다.
  - 계산한 당첨 금액과 사용자의 구매 금액을 바탕으로 총 수익률을 계산한다.
~~~

---

## 🔍 소감
- 벌써 세 번째 우아한 테크코스 과제를 맞았습니다. 이번 주차도 개인적으로 느낀점이 많습니다.
- 이번 주차는 최종 과제처럼 제한 시간 내에 구현하려고 노력을 많이 했으나 실패했습니다...😥

### 😎 도메인이 뭘까요? ###
- 1주차에도 같은 고민을 했던 기억이 납니다. 어떤 식으로 역할을 분리해야 될지 고민이 많았습니다.
  - 이번 주차에는 새롭게 'domain'이라는 패키지를 생성하였습니다. 
- 이유는 '도메인 로직'이라는 단어 때문이었습니다. 추상적으로 도메인에 대해서 알고 있었지만, 
실제 코드에서 어느 범위까지 도메인이라고 생각하고 작성해야 할지 감이 잘 잡히지 않았습니다.
 - 일반적으로 도메인이란 '소프트웨어가 풀고자 하는 현실 세상의 문제'라고 표현됩니다. 
   - 그래서 제 나름대로 이번 주차 과제에서는 '하나 이상의 독립적인 기능을 가지면서 테스트를 진행할 수 있는 범위'라고 생각하고 구현을 진행하였습니다.
   - 과제 요구사항을 크게 '로또 자체' / '사용자의 로또 구입' / '로또 당첨을 위한 번호' / '로또 당첨 결과' / '로또 당첨 통계'으로 나누었으며,
 그 결과로 Lotto, LottoPurchase, LottoWinningNumber, LottoResult, LottoPrize으로 분리하였습니다.

### 🤓 기능 명세 활용하기 - 살아있는 문서를 만들자! ###
- 이번 주차에는 기능 명세에서 메서드 네임까지 함께 달아두었습니다. 이는 살아있는 문서를 만드는 첫 걸음이었습니다.
  - 지난 주차까지는, 단순히 기능 명세는 참고용이지, 그렇게 크게 신경쓰지 않았습니다. 신경쓰지 않았기 때문에 이미 기능은 다 구현한 상태로 후반부에
  부랴부랴 기능 문서만 수정하는 일이 발생했습니다. 결국 기능과 문서가 묘하게 일치하지 않는 문제도 발생했었습니다.
- 그래서 이번 주차에는 도메인 설계를 진행하면서 기능 명세를 주기적으로 작성하였습니다. 명세를 보고 먼저 코드부터 작성해나가는 것이 아닌,
요구사항을 보고 어떤 기능을 구현할지, 기능별로 먼저 생각하는 습관을 들였습니다. 
  - 덕분에 이번 과제에서는 초기 1시간 30분 정도는 명세 작성 및 로직 설계를 진행했던 것 같습니다. 초기에는 오래 걸리는 명세 작성이 낭비일지도 모른다는
생각이 들었지만, 후반부로 갈수록 명세서를 보며 코드를 짜게 되자 어떤 부분에서 리팩토링이 필요한지, 어떤 도메인에서 새로운 기능을 구현해야 되는지 쉽게 파악할 수 있었습니다.
  - 가장 놀랐던 점은 기능 명세에 따라 코드를 작성하자, 후반부에는 각 기능을 조합하는 일만 남았던 것이었습니다. 
작은 단위부터 만들어 나가며 마지막에 모든 기능을 조합해나가자 오류 파악도 손쉬웠으며, 코드의 전반적인 로직 자체를 바꾸는 일이 거의 없게 되었습니다.
- 앞으로도 기능 명세를 꾸준히 작성해나가며 설계대로 코딩을 해나가야겠다고 깊게 깨달았습니다...!

### 😃 Enum 활용하기 ###
- 이번 주차에 추가된 요구사항인 enum 활용을 어떻게 할지 고민했습니다.
  - 지난 주차에서는 상수에 대해서 모두 static final 형태로 처리하였기 때문에, Enum을 어떤 식으로 사용하면 좋을지 고민했습니다.
  - enum 타입은 결국 명시적으로 인스턴스 생성을 막고 유용한 리팩토링을 제공해준다고 생각하였기 때문에 기존에 사용한 상수에 적용하기로 하였습니다.
- input, output 메시지에 대해서 처리를 진행하며 name으로는 내부적으로 사용할 이름을, message 필드에는 출력할 메시지를 담았습니다.
  - 그러나, 에러 메시지의 경우 다른 상수와 결합하여 출력해야 되는 경우가 많았기 때문에, 
  enum 타입으로 처리하기에는 각 메시지를 세부적으로 쪼개어서 표현해야 될 것 같다고 판단되어 에러 메시지의 경우 일반 상수 클래스로 처리하였습니다. 
- 또한, enum을 사용하며 삽질도 진행하였습니다. 처음에는 로또 결과에 대해서 금액, 기준 개수, 그리고 사용자의 로또 일치 개수(매치 카운트)에 대해서도 한 번에 enum으로 관리하고자 하였습니다.
  - 그러나, 추후 단위 테스트부터 통합 테스트까지 진행하면서, 여러 테스트가 동시에 발생했을 때 에러가 발생하는 것을 보고,
공통으로 사용되는 enum 타입에 사용자에 따라 값이 변화하는 로또 결과 값을 담는 것은 아니라고 판단하였습니다. 
  - 일관된 값만 제공하는 기준 개수와 금액에 대해서만 처리하는 LottoPrize enum과 LottoResult 클래스를 분리하였습니다. 

### 🤗 테스트 코드 작성하기 ###
- 저번 주차에서 가장 아쉬움이 많았던 부분은 **테스트 코드**에 대한 부분이었습니다. 단순히 '예제로 주어진 테스트가 돌아가면, 
결국 모든 작은 기능들은 성공적으로 돌아가는 것을 보장받은 셈이 아닌가?'라는 어리석은 생각 때문이었습니다.
  - 그래서 이번 주차에서는 단위 테스트와 통합 테스트를 특히 신경써서 구현하였습니다. Intellij의 자동 테스트 클래스 생성 기능을 활용하여,
UI 부분을 제외하고 테스트를 진행할 수 있는 도메인 부분과 검증 로직에 대한 테스트 코드를 작성하였습니다.
  - 테스트 코드 덕분에 입력 제한사항에 대해 다양한 경우를 생각해볼 수 있었습니다. 가령, 문제에서 주어진 건 '로또 번호는 6자리이며, 1~45 사이의 값을 가져야 한다. 쉼표루 분리된 값이 들어온다.'
 정도였습니다. 그러나, 내부적으로는 '로또 번호는 숫자여야 한다. 문자가 들어올 수 없다.'라는 조건이라든지, 혹은 쉼표로 구분된 값이더라도 '1,2,3' 혹은 '1,2.3,4' 이런 식으로 
실제 사용자가 입력할 수 있는 다양한 케이스에 대해서 생각하게 되었습니다. 이번 미션을 넘어서, 앞으로도 개발을 진행할 때 테스트 코드는 꼭 사용해야겠다는 생각이 들었습니다.
- 사실 이 과정에서 private 접근 제어자에 대해서 리플렉션을 사용하여 테스트 코드를 작성하는 게 맞는 것일까? 라는 생각이 들었습니다. 
  - 'private는 결국 외부에서 public으로 접근 가능한 로직을 통해 호출이 되며, 단독으로 호출되지 않기 때문에 테스트를 하지 않아도 된다'라는 결과를 보았으나,
이번 주차의 큰 목표는 '단위 테스트와 통합 테스트를 세부적으로 진행하기, 테스트 코드에 익숙해지기'였기 때문에 리플랙션을 활용하여 private method에 대해서도 테스트를 진행하였습니다.
  - 다음 주차부터는 public으로 접근할 수 있는 통합 테스트에 대해서 다양한 테스트 케이스를 넣어가며 진행해나가고자 합니다.
- 또한, 다음 주차의 작은 목표로는 @ParameterizedTest, @ValueSource 등, 다양한 테스트 보조 어노테이션을 사용해보고자 합니다!