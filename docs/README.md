# 구현할 기능 목록

> 유효값을 확인하는 부분 중 중복 서술되는 부분이 많아 따로 분리하였습니다. **Bold**처리 된 글자를 사용하여 기능 목록에서 수행할 유효값 체크를 적었습니다.

## 기능 목록

- [x] 구입금액을 요청한다.
- [x] 로또 구입 금액을 입력받는다.
  - [x] 입력받은 로또 구입 금액을 정수로 전환한다.
- [x] 로또 구매 갯수만큼 로또를 구매한다.
  - [x] 입력받은 로또 구입 금액값이 올바른지 확인한다(**1000**).
  - [x] `Randoms`의 `pickUniqueNumbersInRange()`를 활용해 1부터 45의 번호 6개를 오름차순으로 뽑아 로또 번호로 지정한다.
  - [x] 로또 구매 갯수와 로또 번호들을 출력한다.
- [x] 당첨 번호를 입력받는다.
  - [x] 입력받은 당첨 번호들을 정수로 전환한다.
    - [x] 입력받은 당첨 번호들이 올바른지 확인한다(**6개, 로또의 범위, 중복값**).
- [x] 보너스 번호를 입력받는다.
  - [x] 입력받은 보너스 번호를 정수로 전환한다.
    - [x] 입력받은 보너스 번호가 올바른지 확인한다(**로또의 범위**).
- [x] 로또 당첨 번호 객체를 생성한다.
  - [x] 입력받은 당첨 번호들과 보너스 번호가 올바른지 확인한다(**당첨 번호에 포함**).
- [x] 당첨 통계를 도출한다.
  - [x] 구매한 로또 하나씩 몇 등인지 확인한다.
    - [x] 번호가 몇 개 일치하는지 확인한다.
    - [x] 일치하는 번호가 5개일 경우, 보너스 볼이 일치하는지 확인한다.
  - [x] 확인한 결과를 정리한다.
- [x] 당첨 통계를 출력한다.
- [x] 수익률(당첨금액 / 구입금액)을 계산한다.
  - [x] 당첨 통계를 바탕으로 당첨금액을 계산한다.
- [x] 수익률을 출력한다.

## 유효값 체크(`IllegalArgumentException`)

- [x] **정수**로 변환할 수 없는 경우
- [x] **1000**으로 나누어 떨어지지 않는 경우
- [x] 숫자의 갯수가 **6개**가 아닌 경우
- [x] **로또의 범위**(1~45)를 벗어난 경우
- [x] **중복값**이 있을 경우
- [x] 보너스 번호가 **당첨 번호에 포함**될 경우

---

> 이하 내용은 3주 차 미션을 진행하면서 생각한 사항들입니다. 생각의 흐름대로 작성하다 보니 보기에 불편하실 수 있습니다. 요약하여 정리한 내용은 [제 블로그](https://velog.io/@eora21/%EC%9A%B0%ED%85%8C%EC%BD%94-%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4-3%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0)에 적어두도록 하겠습니다.

# 초기 구현

## 구현 전 클래스 지정

> 구현할 기능 목록들에 따른 각자의 역할을 생각하고 구현할 클래스를 나눠보았다.

- 로또샵 클래스
  - 로또를 구매하고 확인하는 전반적인 진행 담당
- 메시지 출력 클래스
  - 구입 금액 입력 요구, 로또 갯수, 로또 번호 출력 등의 기능을 담당
- 메시지 입력 클래스
  - 사용자가 입력한 메시지를 올바른 자료구조로 변형
- 유효값 체크 클래스
  - 입력받은 값이 올바른지 확인
- 로또번호 클래스(문제에서 주어진 Lotto 클래스 이용)
  - `Randoms.pickUniqueNumbersInRange()`를 통해 생성된 로또 번호로 생성
- 당첨번호 클래스
  - 사용자의 입력을 통해 당첨 번호와 보너스 번호를 지정
- 통계 클래스
  - 로또번호 클래스와 당첨번호 클래스를 비교하며, 당첨 통계를 작성
- 계산 클래스
  - 당첨 통계를 바탕으로 당첨금액과 수익률을 계산

## 고민한 사항

- 시작하자마자 출력 클래스에 대한 고민이 생겼다.
  - 출력할 내용은 크게 7가지(구입금액 입력 요구, 구매갯수 확인, 구매한 로또 번호들, 당첨번호 입력 요구, 보너스번호 입력 요구, 당첨 통계, 수익률)이다.
    - 구입금액 입력 요구, 당첨번호 입력 요구, 보너스번호 입력 요구는 지정된 텍스트를 출력한다.
    - 나머지 항목들은 지정된 텍스트 + @를 출력한다.
  - 그렇다면 해당 클래스는 `지정된 텍스트 출력`, `지정된 텍스트 + @ 출력`으로 나눌 수 있다.
  - 지정된 텍스트들은 바뀔 일이 없으며, 이는 enum 클래스로 선언하는 게 나을 것 같았다.
    - 2주차 때 우연치않게 enum에 대해 공부하게 되었는데(3주차에서 나올 줄 몰랐어요.. 정말로!), 덕분에 생각의 흐름을 쉽게 가져갈 수 있던 것 같다.
  - 출력 클래스 자체를 enum으로 해보고 싶었으나, 텍스트 + @에 대한 다형성을 어떻게 구현해야 할 지 막막했다. 따라서 리팩터링 때 생각해보기로 했다.
- 유효값 체크 클래스의 출력 텍스트 또한 enum으로 선언할 수 있다고 생각되었다.
  - `입력값이 null입니다.` 등의 텍스트도 지정된 텍스트이므로, 해당 값들도 enum으로 선언할 수 있을 것 같았다.
  - 다만, 출력 클래스에서 지정한 값들과는 별개로 관리해야 한다고 생각되었다. 둘 다 같은 형태이긴 하겠지만, 사용되는 목적이 다르니 `LottoText`와 `ExceptionText`로 작성하면 좋을 것 같았다.
  - 그렇다면 Text라는 기본 클래스를 만들고, 위의 두 enum 클래스에서 상속하면 편하겠다!
  - 헌데 enum 클래스는 상속이 불가했다. 함축적으로 enum 객체를 상속받고 있기 때문이라 한다. 따라서 그냥 같은 형태로만 만들어주었다.
  - 대신 직접 내용에 해당하는 `IllegalArgumentException`을 던질 수 있도록 작성했다. 어라.. 이러면 `ExceptionText`로 작성하면 안되는데..?
  - 유효값이 아닐 경우를 모아두는 거니까.. 간단하게 `Invalid`로 하기로 했다.
- 테스트코드를 위한 메서드를 main에 작성하는 게 옳은 걸까?
  - NULL 테스트를 위해 코드를 작성했다. 이 때, 해당 메시지가 `입력값은 null일 수 없습니다.`가 나오는지 정확히 파악하려면, 그리고 해당 메시지가 변경되어도 검증할 수 있으려면 `Invalid.content`를 얻어와야 한다.
  - 그러나 main 내에서는 `Invalid.content`를 얻어올 일이 없으며, 테스트코드를 위한 메서드를 작성하게 될 것 같았다.
  - 그렇게 좋은 방법은 아닌 것 같아 에러메시지 내부에서 `null`을 포함하는지만 검사하기로 했다. 극단적으로 갔을 때, 테스트코드가 주가 되어버리는 게 생길.. 어? TDD에선 그런 식으로 하지 않을까..?
  - 고민을 계속 하다가, 결국 `Invalid`의 `toString()`에서 `content`를 반환하는 식으로 오버라이드하였다. 따라서 내부 코드도 조금 단순하게 가져가고, 테스트코드에서도 제대로 비교할 수 있도록 해 보았다.
  - 하지만 본질적인 의구심은 해결하지 못 했다.. 확장적인 코드를 작성하여 main과 test를 둘 다 신경쓰는 방식을 도입하는 게 제일 나은 것 같아서 해당 방법을 구상하였으나, 실제 TDD를 작업할 때는 어떠한 방식을 선택할까?
  - `비즈니스 로직과 완전히 상관없는, 테스트만을 위한 메서드는 필요하지 않다`라는 답변을 얻었다. 물론 사람마다 다르다곤  하지만.. 나도 여기에 동의하는 바이다.
  - 또한 테스트코드에서는 에러메시지를 하드코딩하고 비교하는 방법이 쓰이는 것 같다. 잘못된 에러메시지를 가져오면 바로 알 수 있게끔.. 헌데 내 구조는 에러메시지가 변화되지 않는 형태이고, 검증 메서드에 값을 던졌을 때 해당 에러가 제대로 발생하는지 확인하는 형태이기 때문에.. 이부분은 조금 더 생각해봐야 할 것 같다.
- 20억을 초과한 값
  - 1등보다 많은 값만큼 로또를 살 사람은 없다고 생각.. 했으나, 시뮬레이션이기 때문에 있을 수도 있다고 판단되었다..
  - 헌데 값을 Int형으로 제한할 경우, 21억이 넘어가면 에러가 터진다.
  - 그렇다고 Long을 쓰자니, 로또 용지를 어마어마하게 발급해줘야 한다..
  - ![image-20221110150724621](README.assets/image-20221110150724621.png)
  - 아.. 판매량에는 제한이 없구나.. 그럼 어마어마하게 발급해주는 것도 있을 수 있겠구나..
  - 가게마다의 제한은 있을 수 있겠지만.. 적어도 21억 이상으로 시뮬레이션을 돌리고 싶은 사람은 있을 수 있겠다 싶었다.
  - 근데 21억정도만 사도 210만개의 출력이 콘솔에 찍히는데, 그 이상으로 받아들인다면 좀 무리이지 않을까?
  - 제한 사항은 내가 설정하는거니, 가게 사정상 Int형의 범위를 벗어나는건 안된다고 설정하고 진행해야겠다 싶었다. Long을 하고 싶긴 하지만.. 그에 따를 나비효과가 좀 무서웠다 ㅠ
- 값 확인보다 차라리 숫자로 바꿔보며 나오는 에러를 처리하는게 낫지 않을까?
  - null, 문자열, 정수값을 넘은 경우 모두 `NumberFormatException`을 발생시킨다.
  - 굳이 내가 확인처리를 하지 않고, `Integer.parseToInt`에게 할 일을 맡긴 뒤 나오는 에러를 처리해주는게 더 효율적이지 않을까?
    - 0 이하의 값인지만 더 확인해주면, 따로 건드릴 일이 없을 것 같았다.
    - 더 이해하기 쉽고, 확실한 처리 능력일 듯 했다.
  - 따라서 null이 입력된 경우, 숫자가 입력되지 않은 경우, 정수값의 범위를 넘은 경우에 대한 사항들을 모두 `Integer`에게 맡기기로 했다.
  - 헌데 이렇게 되니, `Validate`가 해당 과정을 지녀야 할 지 의심되었다. 미리 확인하는 것과 변형하며 나오는 에러를 도출해주는 건 다르지 않나 싶었다..
  - 따라서 네이밍을 `Convert`로 지어주고, 해당 전환과정 중 혹시 모를 에러를 살펴본다는 식으로 구성하기로 하려 했다. 그러나 이미 Invalid가 에러메시지를 넘겨주는 녀석이니, 이 녀석을 잘 작성하여 다형성까지 구현해주고 싶은 마음이 생겼다.
  - 구글링으로 [인터페이스를 구현한 Enum 클래스](https://vvshinevv.tistory.com/78)를 확인하였고, 해당 방법을 사용해보기로 했다. 그러나.. 애초에 enum은 같은 형태를 지닌 녀석들을 나열하기 위함이고, enum 객체 하나마다 파라미터를 달리 받아 도출해내는 건 class에서의 역할로 보였다. 에러메시지는 여러 파라미터 타입을 받으며 때에 따라 동작해야 하고, 이를 모두 enum으로 퉁치려는 건 위험해 보였다.
  - 억지로 구현해보려고도 했으나.. 해당 블로그 글에 '[특별히 Generic Parameterized Type에 제한](https://vvshinevv.tistory.com/56)을 두지 않으면' 가능하다는 듯 보였다. 나는 파라미터를 하나씩 세팅하려 했으니.. 해당 조건에 맞지 않았다.
  - 물론 방법이 있을 지도 모른다. 하지만 몇 시간 째 이것만 붙잡고 있느라 다른 것들을 제대로 구현하지도 못 한 상황이니, 나중에 더 공부하기로 하고 우선은 `Convert` 내부를 완성시키기로 했다.
  - 헌데 또 마음에 들지 않았다. `Convert` 자체에서 유효값을 확인하게 되면, 다른 클래스에서 유효값을 검사하게 될 시 코드 중복이 생길 수 있었다. 그렇다면 `Validate` 클래스가 따로 구분이 되어야 했다.
  - `Validate` 클래스가 검사하던 도중 에러가 발생하면 `Invalid` enum 클래스를 사용해 예외를 발생시킨다. 헌데 `Invalid`는 어디서나 접근할 수 있었고, `Validate`의 역할을 다른 곳에서 대신할 수도 있었다.
  - 따라서 `Invalid` 자체를 `Validate` 안에 작성해서 사용하던가, 아니면 `Validate`가 에러를 발생시키는 부분을 제거하거나, `Validate` 자체에서 여러 파라미터에 대응하여 에러를 판단해야 했다.
  - 마지막 방법은 지금까지 계속 실패한 방법이고, 첫번째나 두번째를 사용해야 했다.
  - 근데, 굳이 에러 관련 텍스트를 enum으로 지정해야 할 필요가 있을까? 지난주 프로젝트를 진행하며, enum의 목적은 전역 상수를 편하게 관리할 수 있는 방법이었다. 하지만 에러에 대한 설명은 재활용되지도 않고, 오히려 `Validate`의 책임을 뺏어가며 다른 곳에서의 접근을 허용하는 형태였다.
  - 따라서 enum을 해제하고, 텍스트 자체를 `Validate`에서 사용하기로 했다.
- 그렇다면 다시 돌아와서, `Integer.parseToInt`를 실행하다 에러가 발생했을 시 어떻게 처리해야 하는가?
  - `Convert`는 값의 전환만 책임진다.
  - `Validate`는 값의 확인을 책임진다.
  - 값을 전환하다 에러가 나는 경우는, 결론적으로 `Convert`의 책임이 있다.
  - `Convert`는 값을 전환하다 생기는 에러를 책임질 의무가 있다.
  - 즉 `Validate`는 문제의 조건에 대한 확인을, `Convert`는 값의 전환을 책임진다고 하면 `Convert`에서 Exception 처리는 자연스러울 수 있다.
  - `throw new IllegalArgumentException`을 `Validate`에서만 처리하는 건 오히려 각각 클래스의 책임을 회피하는 것과 같다. 각 클래스는 자신의 메서드를 실행시키는 도중 나오는 예외를 스스로 처리해야 할 것이며, `Validate`는 단지 조건에 맞지 않으면 `IllegalArgumentException`을 던지는 것일 뿐, 모든 예외를 맡을 이유는 없다.
- 로또 당첨 enum의 구조를 어떻게 잡아야 할 것인가?
  - enum 클래스로 1등부터 등외까지 작성한 와중, 문제가 생겼다. 2등의 기준은 `로또 번호를 5개 맞히고, 보너스 번호를 맞췄을 때`이다. 3등의 기준은 `로또 번호를 5개 맞췄을 때`이다.
  - 내부 값의 차이가 있어야 하는데, 2등과 3등 둘 다 로또 번호는 5개를 맞춘 상태이다.
    - 상금 차이는 있지만.. 우선 맞춘 개수로는 1:1 매칭이 불가하다.
  - 따라서 제대로 된 순위를 발표하려면, 로또 번호를 5개 맞힌 상태에서 보너스 번호를 검증하여 2등과 3등을 나눠야 한다. Map을 사용하여 맞춘 갯수와 등수(2등 제외)를 매칭시켰고, 3등인 경우 보너스번호를 판별하여 2등으로 올릴 지 말지 결정하는 로직을 구현했다. 이는 enum이 아니더라도 충분히 구현할 수 있는 방법이며, enum의 의의가 없는 듯 했다. 어떻게 하면 enum을 제대로 잘 살릴 수 있을까?
  - 단순히 로또 번호를 맞춘 갯수로는 힘들고.. 그렇다고 보너스 번호까지 필드값으로 주자니, enum에 맞는 구조인지 모르겠다는 생각이 들었다.
    - 보너스 번호는 2등만 신경쓰면 되는 값이다. 다른 등수들은 신경쓸 필요가 없다.
  - 그렇다면 로또 번호를 맞췄을 때 2점, 보너스 번호를 맞췄을 때 1점을 주면 어떨까?
    - 다른 사람이 코드를 한 눈에 보고 이해할 수 있을까? 2등과 3등을 나누기 위해 한다지만.. 점수로 매겼을 경우 기존의 로또 당첨과 이질적인 형태라 점수에 대한 규칙을 참고하지 않으면 힘들 것이다.
  - 그렇다면 차라리, 맞춘 로또 갯수와 금액을 따로 분리하여 들고 있으면 되지 않을까?
    - 맞춘 로또 갯수가 5개일 때, 보너스 번호가 포함되어 있으면 금액 수령을 한 단계 올려주는 거니까.. 어쩌면 나열한다는 의미에서 이 부분이 더 맞을 것 같다.
    - 그렇다면 `3, 4, 5, 6`과 `5등, 4등, 3등, 2등, 1등`으로 개수의 차이가 난다.
    - 해당 부분은 통계를 계산할 시에 로또 번호 5개를 맞췄으면서 보너스번호를 맞췄는지의 유무를 확인하고 등수를 올려주는 방식으로 하면 될 것 같은데.. 그럼 두 객체가 완전히 분리되어있고, 통계시에 매칭시켜주는 로직이 따로 존재해야 한다.
    - 근데 이러면.. 지금 작성한 구조랑 큰 차이가 있나?
    - 차라리 맞춘 갯수를 enum으로 선언하고 등수를 반환하는데, 5개를 맞춘 경우에만 특별한 로직으로 2, 3등을 가려 결정해주게끔 enum 내부에서 하는게 더 나을 것 같았다. 그렇다면 갯수와 등수에 대한 enum을 따로 선언하고.. 5개 맞췄을 때 보너스 번호를 맞춘 유무에 따라 2, 3등 반환 조건을 설정하고.. 다른 항목들은 해당 유무에 상관없이 관계된 등수 반환하고..
    - 오히려 더 이해하기 어렵지 않을까..? 단순한 게 제일이니까..
  - 그냥 현재 매칭 구조를 가져가면서, 매직넘버를 enum으로 치환하는 방법으로 하는게 제일 나을 것 같다.
  - 아 잠깐만.. 당첨 통계도 깔끔하게 가져가려면.. enum에 보너스 필드값 추가하는 게 좋아보이네..
  - 보너스 필드값을 추가하고, 내부 검색을 통해 1등부터 5등까지를 검색하며 가져오는 방식을 써야겠다. filter가 필요하니까 stream을 사용해보는걸로
  - [Enum을 생성하면서 Map을 관리하는 방법이 있다..!](https://stackoverflow.com/questions/27807232/finding-enum-value-with-java-8-stream-api) 해당 방법을 사용해보기로 했다. 와.. 상상도 못한 방법이다. 내가 스스로 해당 방안을 생각해 낼 수 있었을까..? 우선은 해당 방법으로 Enum 내에 검색도구를 넣고, 로또를 맞춘 갯수와 보너스에 대한 조건을 달아 값을 빼오는걸로 했다. 보너스는 5개를 맞췄을 때가 아니면 쓸모없으니, 기본적으로 false를 주되 5개를 맞춘 상황에서 지닌 값과 보너스값이 일치하는지의 여부에 따라 TF를 주기로 했다.
  - 결과도 EnumMap이라는 게 있어서 해당 구조를 사용해보았다. 순서가 지켜지는게 진짜 좋구나.. 출력에도 써먹어봐야겠다.

# 리팩터링

## 고민한 사항

- 모든 출력문을 Enum으로 유지할 필요가 없다고 느껴져서 출력 클래스에 해당 구문들을 작성하였다. 훨씬 가독성있는 듯 하다. 단, ERROR 출력은 모든 예외 시 나와야 하기 때문에 따로 작성.. 하긴 했는데, 어차피 위쪽으로 예외 쭉 올리는 형태라면 한 곳에서만 작성하면 될 것 같다.
- 로또의 가격을 enum을 이용하여 전역상수로 선언하였다. `LottoRule`에 이미 int값이 주어진 enum이 있지만, 아무래도 규칙과는 다른 성격이니까.. 전역상수가 아니어도 괜찮긴 하지만, `Validate`내에서도 사용하기 때문에 옮겼다. 헌데, 꼭 `Validate`에서 값들을 검사해야 하는진 의문이다. 내 역할에 맞게, 내가 처리해야 하는 값들을 검사하는 형식이 더 낫지 않을까? `Validate`에서 검사하여 Exception을 발생시키는 건 어쩌면 다른 클래스들과 깊게 연관되는 형태는 아닐까? 흠.. 좀 더 생각해봐야겠다.
- `Prize` 내에 로또 일치 조건과 상금 설명을 삭제하고 `Print`에서 맡아 처리하기로 했다. `Prize`에서 미리 가지고 있을 필요가 없다고 느꼈고, 어디까지나 출력문에서 사용할 것이기에 변경.
- 클래스가 너무 많아서 MVC의 기준에 따라 한번 나눠봤다. 헌데 `Controller` 하나, `View` 하나, 나머지는 다 `Model`로 구분이 되어버렸다.. 이게 아닌가..?
- 데이터 형태를 지정하는 건 `Model`, 로직을 담당하는 건 `Service`로 나눴다. `Repository`는 DB 데이터를 가져오거나 변경시키는 것들인데.. `Model`을 DB라 생각하고 작성해야 하나? 그러면 `Model` 내 `get()`같은 로직을 다 옮겨와야 하는 건가..? 이 부분은 잘 모르겠다.
- `Prize`의 검색 메서드도 좀 고민이다. 해당 클래스를 `Model`에 넣어놨는데, 검색하여 찾는 건 어떻게 보면 `Service`쪽에 가까운 게 아닌가 싶다.. 그럼 다시 따로 만들어야하나..? 아니면 이게 `Repository` 역할인가..? 잘 모르겠다..
- 단위 테스트가 제대로 이루어지려면 `Validate`가 어느 정도 분배되어야 한다고 생각했다. 사용자의 입력을 받는 부분은 현재 숫자를 입력받거나(구입금액, 보너스 번호) 쉼표를 기준으로 숫자를 입력받는(당첨 번호) 두 가지로 나뉜다. 따라서 입력을 처리하는 곳에서는 단순히 저 조건에 맞게끔만 변환을 하고, 해당 데이터들을 각각의 클래스에 넘기도록 하는 게 낫지 않을까 싶다. 그 후 클래스에서 자신의 형태에 따라 값을 검증하는 게 어쩌면 하나의  클래스에서 하나의 역할을 제대로 맡는 게 아닌가 싶다. 현재 구조에서는 `Validate`를 거쳐서 옳은 데이터가 들어온 상황을 가정하지만, 만일 코드의 구조가 변경되어 다른 곳에서 바로 클래스를 생성하거나 값을 대입할 때 제대로 된 검증이 이루어지기 힘들 수 있다.
- 로또를 상속받은 당첨로또를 어떻게 하면 좋은 구조로 할 수 있을까? 로또 번호를 입력받자마자 경고를 낼 수 있으려면.. 생성자에서는 로또 번호만을 확인해야 한다. 그러면 보너스 번호를 final로는 설정하지 못 하니.. 따로 set을 해줘야 하는데 그건 맘에 들지 않는다. 한 번 설정하면 바꾸지 못하게 해야 하는데.. 그렇다고 생성 타이밍을 뒤쪽으로 끌고가는건 별로 좋은 생각이 아닌 것 같다.
- 보너스 번호를 아예 따로 둔다고 한다면, 로또 내의 `validate`를 사용하지 못 한다. 해당 메서드를 따로 빼놓는것도 별로고.. 잘못 해서 로또를 훼손시키기라도 하면 요구사항에서 벗어날 수도 있고.. `List<LottoNumber>`식으로 바꿔서 이미 검증한 값을 받는 형태로 만들고 싶지만 테스트케이스의 형태와 맞지도 않고..
- 차라리 로또 번호를 지정하는 클래스를 로또에서 상속받는걸로 하면 어떨까? 로또 번호에 대한 검증을 포함한 채 상속만 받는다면.. 구조를 깨뜨리진 않겠지만, 메서드를 따로 빼놓는것과 큰 차이가 없을 것 같다..
- 기존처럼 로또를 상속받는 게 제일 나을 것 같긴 한다. 값 검증도 유효하게 가져갈 수 있고, 기존의 테스트코드도 변경시키지 않을 수 있다. 다만 해당하는 상태에서 로또 번호를 입력받자마자 예외처리를 하려면.. 로직을 어떻게 해야하나..
- 기존 로또 클래스를 건드리지 않고 작성할 수 있는 최선의 방법은 아무래도 로또 숫자에 대한 클래스를 만들고 상속을 이용하는 게 제일 좋을 것 같다..
  - 로또 숫자 클래스
    - 로또 클래스
    - 보너스 번호 클래스
  - 로또 클래스와 보너스 번호 클래스를 모두 지정하는 당첨로또 클래스
- 이런 구조로 가야 그나마 나을 것 같긴 한데.. 정말 맘에 들지 않는다 ㅠ 로또 클래스가 로또 숫자들을 List로 지닌 형태가 아니라면 검증 메서드 분리해놓은 형태와 다를 것 없어 보인다..
- 아, 로또번호를 상속받되 보너스번호 입력에 대한 내부 메서드를 구성하면 되지 않을까..?
  - 근데 이래도 괜찮나..? 당첨로또가 input을 호출하는게.. 구성엔 맞지 않을 것 같다..
  - 그냥 final 빼야겠다.. 아쉽지만.. ㅠ
- `검증 후 생성`과 `생성 시 검증`에 따른 고민이 이렇게 커질 줄 몰랐다.. 아니 정확히는 `검증 메서드 분리`에 대한 고민이겠지..? 한 곳에서 검증을 맡아 하되 클래스를 생성할 때 마다 호출해 주는 건.. 모든 클래스에서 검증 클래스를 불러오는 것과 같으니 이것도 그렇게 좋은 건 아닌 것 같고.. 결국 `생성 시 검증`하는 게 정합성 검증에 제일 좋은 형태인 것 같긴 한데.. 아 모르겠다 ㅠ
-  분명 더 좋은 해결법이 있을텐데, 왜 떠오르지가 않지..? 물론 보너스번호까지 받고 나서 검증하면 되긴 하겠지만, 당연히 틀린 값 들어왔을때 바로 알려줘야지..
- Lotto 클래스의 `numbers` 접근 제어자만 바꿀 수 있는 거라면.. 혹시 타입은 바꿔도 되는 걸까 싶었는데 `필드를 추가할 수 없다`라는 사항 때문에 엄청난 고민에 빠졌었다.. 혹시 모르니 바꾸지 않기로 했다.
- final을 주지 못 하는게 너무 맘에 들지 않아 계속 생각했는데, 혹시 당첨 로또 내에 `보너스번호로 지닐 수 있는지`를 검증하는 메서드로 숫자를 검증하고 따로 넘기면.. 음, 필드값을 지니는것보다 오히려 더 마이너스다..
- set을 이용한다는 것도 맘에 걸린다.. 다른 방법을 찾아봐야겠다.
- 아무리 생각해도, 생성 타이밍이나 검증 구조를 간편히 가져가려면 로또의 근간이 되는 자료구조를 바꾸거나 검증 메서드를 밖으로 빼내야한다.
  - 자료구조를 바꾼다면 `로또 숫자`에 해당하는 클래스값을 List로 지니고 있으면 될 것이고, 해당 클래스에 해당하는 보너스 숫자 또한 쉽게 검증 가능하다.
  - 검증 메서드를 밖으로 빼내야한다면 메서드를 지닌 로또의 상위 클래스를 생성하던가, 또는 로또 룰 기반 검증이므로 `LottoRule` 내의 static 메서드로 만드는 게 제일 나을 것 같다.
- 우선 검증 메서드로 구현해보고.. 자료구조 변경은 좀 무섭기 때문에 시도는 해보되 확신이 들면 업로드해야겠다..
- 로컬 브랜치를 파서 작업해봤는데 해당 자료구조 변경으로 인해 많은 것들을 손봐야 하고, 오히려 복잡도가 증가하는 것 같아 검증 메서드를 분리하고 선언하여 사용하는 것으로 하기로 했다. 다른 분들은 어떻게 구현했을지 정말 궁금하다..

## 알아본 사항

### 일반 클래스와 Enum 클래스의 생성 순서 차이

> Enum 클래스의 static 변수와 메서드가 Enum 객체들 생성 이후에 돌아가는 이유

`PrizeSearchTool`이 `Prize`와 너무 깊게 맞물려있기에 검색 기능을 `Prize`내에 넣어보기로 했다.

![image-20221112182414627](README.assets/image-20221112182414627.png)

> 6개의 enum을 지정해놓았다. 생성자를 통해 생성 시 `updateSearchTool`을 통해 해당 객체값을 `matchPrize`에 등록한다. (메서드에 static이 붙어있는 건 `PrizeSearchTool`에서 옮겨오다가 깜빡하고 지우지 않음..)

헌데.. NPE가 떴다. matchPrize가 생성되지 않았다고 한다.

엇, 왜지? static이면 제일 먼저 올라간다고 했는데?

의아해서 따로 테스트를 만들어 돌려보았다.

![image-20221112185648021](README.assets/image-20221112185648021.png)

![image-20221112190324878](README.assets/image-20221112190324878.png)

![image-20221112190337153](README.assets/image-20221112190337153.png)

오히려 Enum 클래스에서는 static이 제일 늦다..?

이해가 가지 않아 [구글링을 한 번 시도해봤다.](https://stackoverflow.com/questions/11419519/enums-static-and-instance-blocks) 내가 제대로 이해한 게 맞다면, enum 객체를 선언하는 것도 하나의 static 형식이고, 따라서 객체를 생성할 때 static 우선순위에 의해 enum 객체 생성(일반 블럭 -> 클래스 생성)이 이뤄진다. 그 후에 나머지 static이 채워지는 것이라 본다면.. 해당 순서는 납득이 된다.

그렇다면 내 코드는 어떻게 바꿔야 할까 생각해보다가, 차라리 enum 생성이 다 끝나면 `Prize.values()`를 통해 Map을 채워보기로 했다.

![image-20221112192213482](README.assets/image-20221112192213482.png)

대부분은 검색 메서드 로직을 저 `values()` 에 `stream`을 건 후 + `filter`를 통해 값을 찾는 것 같다. 헌데 Map으로 해보고 싶어서.. 아무래도 `match`와 `bonus`로 두 번 필터 거는 것보단 Map이 속도가 더 빠르지 않을까 생각한다.

## 최종 클래스 구조

- 시뮬레이터 클래스(LottoSimulate)
  - 로또를 구매하고 확인하는 전반적인 진행 담당
- 로또 클래스(Lotto)
  - 로또 객체를 생성 시 값이 유효한지 확인
- 로또 규칙 클래스(LottoRule)
  - 로또 규칙에 따른 내용을 지정, 규칙에 따른 유효값을 파악하는 메서드 내장
- 상금 클래스(Prize)
  - 로또의 순위에 따른 조건과 상금 등을 확인, 조건에 맞는 상금을 받을 수 있도록 검색 기능 내장
- 당첨 로또 클래스(WinLotto)
  - 로또 인스턴스와 보너스 번호를 지님, 보너스 번호가 유효한지 확인
- 계산 클래스(Caculate)
  - 구입금액과 통계를 바탕으로 수익률을 계산
- 로또 구입 클래스(LottoShop)
  - 입력된 금액이 유효한지 확인 후 `Randoms.pickUniqueNumbersInRange()`를 통해 로또 발행
- 통계 클래스(Statistics)
  - 구매한 로또들과 당첨 로또 클래스를 비교하여 몇 등에 얼마나 당첨됐는지 통계 계산
- 입력 클래스(Input)
  - 유저에게 값을 입력받아 적절한 자료형으로 변환
- 출력 클래스(Print)
  - 유저에게 출력할 안내문을 작성하고 출력


# 느낀 점

- 앞선 2주간 프리코스를 진행할 때 전체적인 코드 구조를 후딱 작성하고 리팩터링하곤 했다. 이번주는 처음부터 코드 방향성에 대해 고민을 하고, 메서드별로 클래스를 부여하고, 단위테스트 코드를 작성하는 식으로 조금씩 천천히 쌓아나갔다. 생각보다 힘들고 오래 걸렸다.. 하루 종일 했는데도 구현 목록의 절반 정도밖에 작성하지 못 했다. 아직 익숙해지지 않아서 그런 것 같다.
- 그래도 뭔가 뿌듯하다. 처음 프로그래밍을 배울 때의 그 느낌이 나는 듯 하다. 차근차근 설명서대로 레고를 짜맞추는 기분? 마구 덩어리째 집어서 턱 턱 올려놓는 느낌이 아니라 재미있다.
- 근데 이걸 어떻게 MVC 패턴으로 옮기지..? 싶다. 매 주마다 다른 분들의 리뷰를 구경하며 하나씩 아이템을 잡았는데, 지난주에는 MVC 패턴을 사용한 분들이 꽤 있어서 도전해보기로 했다. 특히 코드 구성을 많이 배우려고 깃헙 팔로우한 분도 있는데, 그 분도 MVC를 쓰셨더라..
- 코수타에서는 `주어진 걸 열심히 하라`고 했다. MVC를 사용하기 전에 장점에 대해 충분히 이해하고, 정말 좋은 형태구나 싶어 욕심이 생기면서도 리팩터링할 시간이 남으면 시도해봐야겠다.
- MVC를 시도하기 전에 이것저것 알아보며 어떻게 적용해야 할 지 생각해봤는데, 클래스들을 쪼개다 보니 MVC 형태로 구분할 수는 있었고, 패키지로 나눠놓기만 했다. 뭔가 공부하면 공부할수록 너무 깊은 내용까지 내려가는 것 같았고, 필요성이 아닌 이론만 공부하게 되는 것 같아서.. 만약 그 구조를 작성한다 하더라도, 전처럼 내 생각이 담기지 않은 코드를 작성하게 되는 것 같아 우선은 미적용하기로 결정했다. 아쉽다..
- throw를 (부끄럽게도) 지금까지 거의 사용해본 적이 없었고, 어떠한 구조로 되어 있는지도 몰랐는데 테스트코드를 해결하다 알아보게 되었다. 내가 얼마나 튼튼하고 확장성있는 언어를 사용중인지, 그리고 그런 언어로 얼마나 무지하게 작성해왔는지 깨닫게 되는 것 같다..
- 기존에는 처음 코드를 작성하는 시간보다 리팩터링 시간이 더 오래 걸렸고, 이번에는 고민하는 시간 > 코드 작성 시간 > 리팩터링 순이었던 것 같다. 꽤나 오랜 시간동안 고민하고, 생각했던 것 같다. 근데 많이 드러나지 않은 것 같아 슬프다. 지난번에는 `Enum을 적용할지, 말지`에 대해 생각했는데, 이번엔 `어떤 걸 더 건드려야 좋은 구조가 될지`를 생각하다 보니 명확한 답이 나온 것도 없고, 그만큼 커밋이나 리드미에 작성한 내용이 없는 것 같다.
- 그래도 앞선 주차들의 미션보다 더 많은 생각을 하게 되었다. 다른 분들의 코드와 방향성을 비교하며 더 배워갈 생각에 떨린다. 특히나 내가 계속 고민했던 보너스 번호에 대한 검증을 어떤 식으로 구현했을지, 또 MVC패턴을 어떻게 구축했을지 살펴보며 다음 주차의 미션을 어떻게 작성할지 미리 생각해보려 한다.
