# 우테코 프리코스 3주차 소감문(남동우)

이번 과제를 처음 마주했을 때는, 드디어 제 기존의 한계가 온 듯, 압박감이 대단했습니다. 확실히 목이 조여 오는 느낌이 확 들었지만, Divide & Conquer 를 하다 보면 해결할 수 있을 것이라
는 믿음에, 먼저 꼼꼼하게 README.md 에 기능 구현 리스트를 작성했습니다. 2주차보다 확실히 신경쓸게 많이 늘어났고, 천천히 기존의 기능 요구사항을 읽어 나가면서 크게 5가지의 신경쓰면서
구현해야 할 기능에 대해서 적어 나갔습니다. 이까지만 해도 이번에는 몇 시간 먹은 느낌이 들었지만, 당연히 많이 걸리는 것이라고 생각했습니다.

이번에는 바로 Application 을 신경쓰기보다는, 작성한 기능구현 리스트를 바탕으로 부품을 하나하나 만들어 나가듯, 분류대로 클래스들을 만들고 채워나갔습니다. 기존에 꼼꼼하게 작성했다고
생각하는 README 에서의 기능 구현 리스트들의 글귀를 하나하나 곱씹어 가면서 기능들을 만들었던 기억이 생생합니다. 혹시나 빠뜨린 부분이 있을지, 혹여나 이상한 인풋이 들어오면 어떻게 처리할지
하나하나 고민하면서 입력 기능들을 만들었고, 그렇게 인풋이 모두 방어된 상태로 다른 controller 의 기능을 만드니, 확실히 안심이 되는 느낌이 강하게 들었습니다. 

일단 하는데 까지 다른 기능을 만들어 놓고, 핵심 로직을 남겨놓은 상태에서, 슬슬 Java Enum 을 쓰라는 제한사항이 다시금 눈에 들어왔습니다. 이전까지 자바 언어 자체를 많이 사용해 보았지만
Java Enum 을 거의 사용해 보지 않아, 구글링을 하면서 Java Enum 을 사용했던 글들을 몇개 참고해 가면서, 메모장에 입력해 가며 공부했습니다. 나중에 다시 Java Enum 을 사용했던 소감들과,
어떻게 사용해 나가는지 깃허브나 노션에 정리해 놓을 것입니다.

확실히 처음 Java Enum 을 사용할 때는, 일단 공부했다고는 하지만 막막했습니다. 일단 당장 사용할 수 있을 것으로 보이는, 랭킹과 상금, 몇개의 숫자가 포함되는지를 묶어서 Enum 리스트들을
작성했습니다. 그리고 핵심 로직(LottoCounting Method) 를 작성해 가며, 같이 WinningPrize(Enum) 클래스 만이 해줄 수 있는 메서드들을 같이 작성해 나갔습니다. Java Enum 을 쓰면서 어려웠던
점은, 다른 클래스들과 다르게, 객체를 그 자리에서 constructor 를 통해 생성하는 방식이 아니라는 점이었습니다. Enum 의 객체가 될 수 있는 것은, 이미 위에서 정해 놓은 Enum 멤버들 뿐이라는
사실이, 기존과 달라 좀 헷갈리면서도 새로웠습니다. 그래서, Enum Class 에서 함수를 만들어 갖다 쓰려면 static 을 붙여서 쓸수밖에 없다는 것도 깨달아갔습니다. 

그리고, 랭킹을 기준으로, Enum 객체를 하나하나 찾아가는 것을 구글링을 통해 만들어 나갔고, 결국에는 랭킹을 기준으로 그에 상응하는 Enum 객체를 찾는 기능을 만들어 나감으로써 Enum
에 대한 감이 약간 잡힌 듯한 느낌을 받았습니다.

확실히, 핵심 로직을 짜기 전에, 다른 필요한 기능들을 모두 완성해 놓아, 핵심 로직을 구현하는 것은 약간 수월했던듯, 아닌듯 했습니다. 여전히 고민해야 할 부분이 산재해 있다는 생각이
많이 들었습니다. 그냥 기능을 놓고 보면, 쉬운 기능 같아 보여도, 어떻게 하면 내 코드를 보는 다른 크루들이 내 코드를 알기 쉽게 할지, 의미 있는 이름을 작명하는 것에 고민을 많이 했습니다.

그리고 어느 부분까지 private 으로 놓고, 어느 부분까지를 public으로 풀어 놓을지도 많이 고민하면서 개발을 이어 나갔던 것 같습니다. 

그렇게 한순간 한순간 열심히 고민해 나가며, 최종적으로 기능구현을 어느 정도 마쳤습니다. 한번 머릿속을 싹 비우고, 테스트 코드를 만드는 데 다시금 집중했습니다. 맨 처음에는, Input 부분을 
테스팅하는데 많이 신경썼습니다. 문자를 넣었을 때, 특수문자를 넣었을 때, NsTest 를 상속하지 않는데 어떻게 Scanner 부분을 처리할지, System.out.print() 가 들어가는 부분은 어떻게 처리할지,
기존의 NsTest abstract Class 를 보면서 많이 고민했습니다. 그중 가장 어려웠던 부분은, 예외처리를 어떻게 해 줄지 고민하는 것이었습니다. 기존 NsTest 방법에서는, run() 메서드를 구현해 놓고,
Try~Catch 로 구현해 주는 방법을 확인했습니다. 하지만, 단순히 main 메서드 만을 돌려서는, 이번 프리코스에서의 제한사항이었던 "단위 테스트" 를 원활하게 하지 못할 것 같다는 생각이 많이
들었습니다.

프리코스 2주차때부터, 길을 걸으면서도 "요즘 함수형 프로그래밍이 핫하다고 들었는데, 나도 함수형 프로그래밍을 어떻게 사용할지 생각해보자!" 라는 생각에 함수형 프로그래밍 글들을 
기웃(?) 거렸던 적이 있었습니다. 주로 걸어서 이동하거나, 대중교통을 이용할 때, 구글링을 통해서 Functional Interface 에 대한 글들을 몇 개 천천히 살펴보았었습니다. 이번 3주차 테스트
에서, 함수형 프로그래밍에 대한 생각들이 많이 났습니다. 그래서 UserInput 테스트에서는 본격적으로 Functional Interface 를 사용해 예외처리하는 부분을 원활하게 처리할 수 있었습니다. 
void exceptionalRunning() 이라는 메서드를 하나 만들고, 그 부분에 Functional Interface 를 사용하여 Supplier<> 를, 예외처리 러닝의 매개변수로 던져주는 방식을 채택해서 사용할 수
있었습니다. Test를 거쳐야 할 메서드 하나하나마다 inner class들을 만들어 주고, 그 inner class 안에서 Supplier<> 타입의 변수에 그때그때 검사할 메서드들을 넣어서 처리할 수 있었습니다.
그 와중에 효과적인 프로그래밍을 위하여, Supplier<?> 와 같이 와일드카드 문법을 집어넣기도 하면서, 오랜만에 자바에서 안 쓰던 기능들까지 꼼꼼하게 사용해 볼 수 있었습니다.

테스트 코드를 작성하고, 리팩토링하며 InputTest 부분을 다 작성한 후, 다른 기능 하나하나를 어떻게 테스팅할지, 어떻게 하면 잘 된 테스팅이 될지... 기능을 개발했던 시간보다 훨씬 더
많은 시간을 쏟아부었던 것 같습니다. 느낌상, 기능 요구사항을 적는 것은 반나절 정도, 기능 전체를 구현하는데 거의 하루 반이 소비되었다면, 테스트 코드를 만드는 데는 못해도 4일에서 5일은
 소모한 것 같다는 느낌을 많이 받았습니다. 정확히 세어 보지 않아서 모르겠지만, 테스팅 코드가 확실히 기능 구현 코드 양의 2~3 배는 될 것 같다는 생각을 많이 했습니다. 로또 번호를 
자동으로 만들어 주는 부분의 테스팅에서는, 기능을 1000번 반복하며, 숫자가 겹치지는 않는지, 범위 밖의 숫자가 생성되지는 않는지 검사하여 보았고, 그 함수를 사용하는 다른 함수에서는
 오히려, 하나하나 로또번호를 생성해 주는 기능의 테스팅이 끝났기 때문에, 인풋에 해당하는 숫자만큼 Lotto 객체를 만들어서 넣는지만 테스팅할 수 있어서 좋았습니다.

Enum Class 인 WinningPrize Class 의 기능을 테스트할 때는, 거의 모든 케이스에 대해서 다 검사해 본 것 같습니다. 이렇듯이, 거의 모든 함수에 대해서, 할 수 있는 모든 케이스들을 다
 넣어서 테스트로써 점검했고, 확실히 이렇게 꼼꼼하게 검사하다 보니, 중간중간에 미흡한 코드가 발견되어 그 부분을 꼼꼼하게 고칠 수 있어서 좋았습니다. 금요일 저녁부터 시작된 테스트
 코드 만들기였지만, 이 글을 작성하는 오늘 테스트를 다 끝낼 수 있었고, 그 와중에도 이상한 부분이 발견되어 해당 로직을 고쳐야 했습니다. 

처음 기능 구현을 모두 완성했다고 생각했을 땐, 제가 정말 꼼꼼하게 모든 부분을 구현했다고 생각했습니다. 하지만, 거의 모든 케이스들을 하나하나 넣으며 테스트를 진행하니, 사실은 그렇지
 않았다는 것을 다시금 깨달았습니다. 이번 테스트 케이스들을 작성하면서, 저번 주차와는 더 커진 개발 규모 덕이었는지는 몰라도, 개발 규모가 커지면 더 커질수록 메서드 하나하나를 유닛
 테스팅 하는 것의 중요성을 더더욱 깨달았습니다. 만약에 유닛 테스트 없이 중간에 기능들이 에러를 발생시킨다면, 그것이야말로 참 끔찍한 일일 것 같다는 생각이 많이 들었습니다. 

"되면 이게 왜 되는지 자기도 모른다"(?) 와 같은 우스갯소리가 있었던 것 같습니다.  하지만, 유닛 테스트를 하나하나 꼼꼼하게 진행한다면, 위의 우스갯소리와 같은 참사를 확실하게 예방할
 수 있는 것 같아서 더 뜻깊은 것 같습니다. 그리고 4~5일 에 걸쳐서 테스트 케이스들을 작성하면서, 테스트 코드를 하나하나 꼼꼼하게 작성하는 것 그 자체에 대한 생각을 되게 많이 했습니다.
 처음에는, 작성할 테스트 케이스들과 코드가 너무 많아, 이게 맞나 싶은 생각도 많이 들었습니다. 하지만, 테스트 케이스를 바탕으로 테스트 코드를 하나하나 적으면서, 확실히 "이게 맞는
것이다" 라는 생각이 많이 들었습니다. 확실히 꼼꼼한 유닛 테스트를 거치다 보면, 그만큼 자신이 짠 코드들을 더 깊게, 더 많이 보게 되고, 그러다가 통과하지 못하는 부분이 나온다면 고치는,
 그리고 그 테스트 코드들을 남겨 놓으면서, 기능을 하나 고쳤을 때 모든 테스트 코드들을 한방에 돌리면서, 기능에 이상이 생기지는 않았는지 파악하는 것이 매우 매력적으로 느껴졌습니다. 이번에 적은 테스트 케이스들이, 유닛 테스트 하나하나를 다 포함하면 100개가 넘는 것 같았는데, 그 100개가 넘는 테스트 케이스들을 하나하나 직접 돌려보지 않고도, 한방에 실행할 수 있다는 것이 너무 좋았습니다. 

 특히나 테스트 코드들이 소중하고도 대단하게 느껴졌을 때는, 3주차 마지막 날인 오늘, 모든 배열 Type으로 작성했던 부분을 리스트로 고치면서였습니다. 배열을 리스트로 하나하나 고치면서,
 수정해야 할 부분이 한두가지가 아니었습니다. 일괄적으로 다 고치고 나니, 기존에 Lotto[] 배열로써 처리해 놓은 부분들 모두를 고쳐야 했습니다. 테스트 코드들이 없었다면, 이렇게 많은
 코드들을 한방에 모두 고쳐야 했으니 매우 불안했을 것입니다. 하지만, 테스트 클래스들을 한방씩 실행시키며, 1분도 안되는 시간에 100개를 다 실행시키고 나니 여전히 모두 All-Clear
되는 것을 보며 참으로 많이 마음이 놓였던 경험을 했습니다. 

2주차보다 확실히 많은 시간을 쏟아부어야 했던 3주차 과제였습니다. 스스로 몰입하는 것을 넘어, 완전히 이번 미션에 
 매몰되다시피 살아갔던 하루하루가 아닌가 하는 생각이 많이 들었습니다. 깃허브 커밋 컨벤션을 모두 만족시키면서 커밋 기록을
남기다 보니, 100개가 넘는 커밋을 한 자신을 마주하고는, 스스로 뿌듯함 반, 이게 맞는지 반 정도의 소회가 들어서
신기하기도 합니다. 스스로 성장하는 것이 아직 어떤 것인지는 느낌이 아리송합니다. 하지만, 개발하고 테스트하면서 
정말 많은 생각들을 스스로 하면서 지냈고, 스스로 치열하게 고민하고 답을 찾는 이 과정이 성장하는 길이라고 생각한다면
저는 이번 3주차 미션을 수행하면서, 스스로 성장했는지도 모르겠습니다. 계속 메모장에 할 일을 정리하고, 어떻게 기능을
구현할지, 어떻게 테스트를 효율적으로 수행할지 자는 그 순간까지도 고민하며, 머리가 터질 것 같을 때는 오히려 머릿속을
비워주기도 하며, 처음에는 목이 조여온다는 느낌마저 들었던 과제를 이렇게 꼼꼼하게 해결한 자신을 마주할 수 있었던 
시간이었다고 생각합니다. 스스로 대견해지는것 같습니다.

다음에는 어떤 과제가 나올지, 궁금하기도 합니다! 혹시나 이까지 읽어주셨다면, 너무 감사하다는 말씀을 드리고 싶습니다.
확실히 처음부터 확 압박을 받다시피 한 과제를 해결하니, 느낀 점이 너무 많아진 것 같습니다 
